# Memory Management Requirement

Memory management is intended to satisfy the following requirements:
- Relocation
- Protection 
- Sharing
- Logical Organization
- Physical Organization

## Relocation

Programmers typically do not know in advance which other programs will be resident in main memory at the time of execution of their program

Active processes need to be able to be swapped in and out of main memory in order to maximize processor utilization

Specifying that a process must be placed in the same memory region when it is swapped back in would be limiting
- may need to relocate the process to a different area of memory

These facts raise some technical concerns related to addressing, as illustrated in Figure 7.1. The figure depicts a process image.

![Figure 7.1](/imgs/mman1.png)

The OS will need to know the location of:
- process control information
- the execution stack
- the entry point to begin the execution of the program for the process.

Because the operating system is managing memory and is responsible for bringing this process into main memory, these addresses are easy to come by.

However, the processor need to deal with memory references within the program.
- Branch instruction contain - an address to reference the instruction to be executed next.
- Data reference instruction - contain the address of the byte or word of data referenced.

So the processor and OS must be able to translate the memory references found in the code of the program into actual physical memory address
- reflecting the current location of the program in memory.

## Protection

Processes need to acquire permission to reference memory locations for reading or writing purposes

Location of a program in main memory is unpredictable

Memory references generated by a process must be checked at run time

Mechanisms that support relocation also support protection

Memory protection must be satisfied by the processor rather than OS. why?
- OS cannot anticipate all the memory references that a program will make
- Time consuming to screen each program in advance for possible memory referenced violation.
- It is only possible to assess the permissibility of a memory reference at the time of execution of the instruction making reference.

## Sharing

Advantageous to allow each process access to the same copy of the program rather than have their own separate copy

Memory management must allow controlled access to shared areas of memory without compromising protection

Mechanisms used to support relocation support sharing capabilities

## Logical Organization

Almost invariably, main memory in a computer system is organized as a linear or one-dimensional address space, consisting of a sequence of bytes or words. Secondary memory, at its physical level, is similarly organized. While this organization closely mirrors the actual machine hardware, it does not correspond to the way in which program are typically constructed.

Most programs are organized into modules, some of which are unmodifiable (read only, execute only) and some of which contain data that may be modified. If the operating system and computer hardware can effectively deal with user programs and data in the form of modules of some sort, then a number of advantages can be realized:
- Modules can be written and compiled independently, with all references from one module to another resolved by the system at run time.
- With modest additional overhead, different degrees of protection (read only, execute only) can be given to different modules.
- It is possible to introduce mechanisms by which modules can be shared among processes. The advantage of providing sharing on a module level is that this corresponds to the userâ€™s way of viewing the problem, hence it is easy for the user to specify the sharing that is desired.

Segmentation is the tool that most readily satisfies these requirements.

## Physical Organization

Computer memory is organized into at least two levels:
Main memory | Secondary memory
---|---
Fast access at high cost | Slower and cheaper
Volatile | Not volatile
Small capacity holds programs and data currently in use | Large capacity for long term storage of programs and data

The organization of the flow of information between main and secondary memory is a major system concern.

Cannot leave the programmer with the responsibility to manage memory, because
- Memory available for a program plus its data may be insufficient
    - overlaying allows various modules to be assigned the same region of memory but is time consuming to program
- Programmer does not know how much space will be available

# Memory Management

Principal operation of memory management is to bring programs into memory for execution by the processor.

In most modern multiprogramming system it invokes virtual memory that use both segmentation and paging techniques.

Simpler technique that do not use virtual memory:
- Partitioning
    - Fixed Partitioning
        - Equal size
        - Non-equal size
    - Dynamic Partitioning
    - Buddy System
- Simple Paging
- Simple Segmentation

# Partitioning

## Fixed Partitioning

## Dynamic Partitioning

## Buddy System

# Paging

# Segmentation